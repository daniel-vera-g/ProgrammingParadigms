<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Google Go (golang) Concurrency abstractions (futures and promises)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Google Go (golang) Concurrency abstractions (futures and promises)</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="programming-language-abstractions" class="slide section level1">
<h1>Programming language <em>abstractions</em></h1>
<ul>
<li>Hide implementation details</li>
<li>Capture recurring programming patterns</li>
<li>Close(r) to the problem domain</li>
<li>Examples:
<ul>
<li>System-level programming in C</li>
<li>Business applications in Java</li>
</ul></li>
<li><p>Not every abstraction fits every purpose</p></li>
<li><p>Need a rich tool box of abstractions</p></li>
<li><p>Abstractions are either built into the language (e.g. OO in Java) or can be provided as libraries/design patterns</p></li>
<li><p>Abstractions emerge by looking at examples and recognize recurring patterns</p></li>
<li><p>In essence, we require a new 'little' (domain-specific) language which enriches our host language by providing additional combinators (API functionality)</p></li>
</ul>
</div>
<div id="motivation" class="slide section level1">
<h1>Motivation</h1>
<p>Typical use case:</p>
<ol style="list-style-type: decimal">
<li><p>Asynchronous computation</p></li>
<li><p>Result, once available, shall be available many times</p></li>
</ol>
<h2 id="example">Example</h2>
<p>Inform friends about some booking request.</p>
<h3 id="first-try">First try</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := booking()
        ch &lt;- Comp{r, s}
    }()

    <span class="co">// friend 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)
    }()

    <span class="co">// friend 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)
    }()</code></pre></div>
<ul>
<li><p>Channel to communicate result.</p></li>
<li><p>Asynchronous (non-blocking) computation of booking by using a separate thread.</p></li>
</ul>
<p>Issue?</p>
<ul>
<li>Only one of the friends obtains the result.</li>
</ul>
<p>How to fix?</p>
<ol style="list-style-type: decimal">
<li><p>Server guarantees that result can be obtained multiple times.</p></li>
<li><p>Client guarantees that other clients can obtain the (same) result.</p></li>
</ol>
<h3 id="server-tries">Server tries</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := booking()
        <span class="kw">for</span> {
            ch &lt;- Comp{r, s}
        }
    }()

    <span class="co">// friend 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)
    }()

    <span class="co">// friend 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)
    }()</code></pre></div>
<h3 id="client-tries">Client tries</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := booking()
        ch &lt;- Comp{r, s}
    }()

    <span class="co">// friend 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        <span class="kw">go</span> <span class="kw">func</span>() {
            ch &lt;- v
        }()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)

    }()

    <span class="co">// friend 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        v := &lt;-ch
        <span class="kw">go</span> <span class="kw">func</span>() {
            ch &lt;- v
        }()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, v.val, v.status)
    }()</code></pre></div>
<h3 id="summary">Summary</h3>
<ul>
<li><p>Something &quot;simple&quot; gets complicated.</p></li>
<li><p>Design choice hard coded.</p></li>
<li><p>User code hard to read and to maintain.</p></li>
<li><p>Need proper (programming language) abstraction to hide implementation details.</p></li>
</ul>
</div>
<div id="futures" class="slide section level1">
<h1>Futures</h1>
<h2 id="requirements-abstraction">Requirements + Abstraction</h2>
<ol style="list-style-type: decimal">
<li><p>Asynchronous computation</p></li>
<li><p>Result, once available, shall be available many times</p></li>
</ol>
<p>Interface:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Future

<span class="kw">func</span> future(<span class="kw">func</span>() (<span class="dt">int</span>,<span class="dt">bool</span>)) Future

<span class="kw">func</span> (Future) get() (<span class="dt">int</span>,<span class="dt">bool</span>)</code></pre></div>
<p>Use case:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> f Future

f = future(booking)  <span class="co">// non-blocking</span>


<span class="co">// non-blocking access</span>
<span class="kw">go</span> fun() {
     r,s := f.get()
   }()

<span class="co">// blocking access</span>
r,s := f.get()</code></pre></div>
<ul>
<li><p>Think of a future as an initially empty program variable.</p></li>
<li><p>Once a value is supplied, the same value can be retrieved an arbibrary number of times.</p></li>
</ul>
<h2 id="sample-implementation">Sample implementation</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Future <span class="kw">chan</span> Comp

<span class="kw">func</span> future(f <span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>)) Future {
    ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f()
        v := Comp{r, s}
        <span class="kw">for</span> {
            ch &lt;- v
        }
    }()
    <span class="kw">return</span> ch

}

<span class="kw">func</span> (f Future) get() (<span class="dt">int</span>, <span class="dt">bool</span>) {
    v := &lt;-f
    <span class="kw">return</span> v.val, v.status
}</code></pre></div>
<ul>
<li><p>&quot;Server&quot; variant.</p></li>
<li><p>Design choices + implementation details hidden.</p></li>
<li><p>Still some technical issue (&quot;infinite loop), to be solved later.</p></li>
</ul>
<h2 id="examples">Examples</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    f := future(booking)

    <span class="co">// friend 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f.get()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, r, s)
    }()

    <span class="co">// friend 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f.get()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, r, s)
    }()</code></pre></div>
<ul>
<li><p>Easy to read and understand!</p></li>
<li><p>&quot;Future&quot; programming pattern useful in other situations as well.</p></li>
</ul>
<h2 id="extensions">Extensions</h2>
<h3 id="choice-among-multiple-bookings">Choice among multiple bookings</h3>
<p>Suppose we might try two alternative bookings and wish to inform our friends about the first available one.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    f1 := future(booking)
    f2 := future(booking2)
    f := f1.alt(f2)

    <span class="co">// friend 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f.get()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, r, s)
    }()

    <span class="co">// friend 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f.get()
        fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st"> %d %b&quot;</span>, r, s)
    }()</code></pre></div>
<ul>
<li><p><code>alt</code> is a new combinator.</p></li>
<li><p>Chooses among the first available future.</p></li>
<li><p>Result is again a future.</p></li>
</ul>
<h4 id="alt-implementation---first-try"><code>alt</code> implementation - first try</h4>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (f1 Future) alt(f2 Future) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
        <span class="kw">go</span> <span class="kw">func</span>() {
            r, s := f1.get()
            ch &lt;- Comp{r, s}
        }()

        <span class="kw">go</span> <span class="kw">func</span>() {
            r, s := f2.get()
            ch &lt;- Comp{r, s}
        }()
        v := &lt;-ch
        <span class="kw">return</span> v.val, v.status
    })
}</code></pre></div>
<ul>
<li><p>Helper threads start race to retrieve the first avaiable &quot;future&quot; result.</p></li>
<li><p>Pro: Doesn't require any fancy language extension, just channels + goroutines.</p></li>
<li><p>Cons: We end up with some &quot;dead code&quot; (dormant, blocked thread)</p>
<ul>
<li>A smart run-time might detect that there's no alive reference to this piece of code. Unlikely that Go implements this (expensive) garbage collection strategy.</li>
</ul></li>
</ul>
<h4 id="alt-implementation---second-try"><code>alt</code> implementation - second try</h4>
<p>Problem goes away if we use <code>select</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (f1 Future) alt(f2 Future) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        <span class="kw">var</span> r <span class="dt">int</span>
        <span class="kw">var</span> s <span class="dt">bool</span>
        <span class="kw">select</span> {
        <span class="kw">case</span> v := &lt;-f1:
            r = v.val
            s = v.status
        <span class="kw">case</span> v := &lt;-f2:
            r = v.val
            s = v.status
        }
        <span class="kw">return</span> r, s
    })
}</code></pre></div>
<h3 id="closing-a-future">Closing a future</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Future <span class="kw">struct</span> {
    comm <span class="kw">chan</span> Comp
    cl   <span class="kw">chan</span> <span class="dt">bool</span>
}

<span class="kw">func</span> future(f <span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>)) Future {
    ch := <span class="fu">make</span>(<span class="kw">chan</span> Comp)
    c := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>)
    <span class="kw">go</span> <span class="kw">func</span>() {
        r, s := f()
        v := Comp{r, s}
        done := <span class="ot">false</span>
        <span class="kw">for</span> !done {
            <span class="kw">select</span> {
            <span class="kw">case</span> &lt;-c:
                done = <span class="ot">true</span>
            <span class="kw">default</span>:
                ch &lt;- v
            }
        }
    }()
    <span class="kw">return</span> Future{ch, c}

}

<span class="kw">func</span> (f Future) <span class="fu">close</span>() {
    <span class="fu">close</span>(f.cl)
}

<span class="kw">func</span> (f Future) get() (<span class="dt">int</span>, <span class="dt">bool</span>) {
    v := &lt;-f.comm
    <span class="kw">return</span> v.val, v.status
}

<span class="kw">func</span> (f1 Future) alt(f2 Future) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        <span class="kw">var</span> r <span class="dt">int</span>
        <span class="kw">var</span> s <span class="dt">bool</span>
        <span class="kw">select</span> {
        <span class="kw">case</span> v := &lt;-f1.comm:
            r = v.val
            s = v.status
        <span class="kw">case</span> v := &lt;-f2.comm:
            r = v.val
            s = v.status
        }
        <span class="kw">return</span> r, s
    })
}    </code></pre></div>
<ul>
<li><p>Correct usage of <code>close</code> in the hands of the user.</p></li>
<li><p>Multiple <code>close</code> calls lead to failure.</p></li>
</ul>
</div>
<div id="further-examples" class="slide section level1">
<h1>Further examples</h1>
<h2 id="holiday-planning">Holiday planning</h2>
<ul>
<li><p>We ask our bank for the current exchange range, e.g. 100Euros to Dollar.</p></li>
<li><p>The bank will need to consult some traders to tell us the exchange rate. This may take some time.</p></li>
<li><p>There's no point waiting for the answer, there are still lots of other things we need to do for planning our holiday.</p></li>
<li><p>Once, the exchange rate becomes available eventually, we wish to be informed.</p></li>
<li><p>In computer science terms, the above can be expressed as follows</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">f:= future(ask bank <span class="kw">for</span> exchange rate 100Euros to Dollar)

f.onSuccess(<span class="kw">func</span>(rate in) () {
    inform me about the rate
  })</code></pre></div>
<h2 id="short-summary">Short summary</h2>
<ul>
<li><p>A future represents an an initially unknown/incomplete computation.</p></li>
<li><p>The main thread of execution continues.</p></li>
<li><p>Once the computation is successfully completed completed, we wish to retrieve the result.</p></li>
<li><p>In the above, we assume that <code>onSuccess</code> is like <code>future</code> an asynchronous operation. The callback function (argument of <code>onSuccss</code>) will be executed once the future computation is completed successfully.</p></li>
</ul>
</div>
<div id="details---holiday-planning" class="slide section level1">
<h1>Details - holiday planning</h1>
<p>Suppose, we consider either a holiday to the USA or Switzerland. We are given some primitives to query the exchange rate and request some (hotel) room.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> rateEuroToDollar(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) 
<span class="kw">func</span> rateEuroToFranc(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) 

<span class="co">// Input amount in dollar/franc</span>
<span class="co">// Output: reference to some room</span>
<span class="kw">func</span> bookUS(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) 
<span class="kw">func</span> bookSwiss(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) </code></pre></div>
<p>Each of the above primitives returns a pair <code>(int, bool)</code> where the first component contains the result and the second component indicates exceptional behavior. For example, say <code>bookUS(70)</code> yields <code>(34,false)</code> then the room request could not be processed successfuly.</p>
<h2 id="first-attempt">First attempt</h2>
<p>Here is a possible implementation of our holiday planning exercise.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    d, d_ok := rateEuroToDollar(<span class="dv">100</span>)
    r, r_ok := bookUS(d)

    <span class="kw">if</span> d_ok &amp;&amp; r_ok {
        fmt.Printf(<span class="st">&quot;Going to the US %d&quot;</span>, r)
    } <span class="kw">else</span> {
        f, f_ok := rateEuroToSwiss(<span class="dv">100</span>)
        r, r_ok := bookSwiss(f)

        <span class="kw">if</span> f_ok &amp;&amp; r_ok {
            fmt.Printf(<span class="st">&quot;Going to Switzerland %d&quot;</span>, r)
        }

    }</code></pre></div>
<p>Discuss the pros/cons</p>
<ul>
<li><p>What if the US booking finally 'fails'?</p></li>
<li><p>How to take advantage of additional processor resources (cores)?</p></li>
<li><p>The above implies that we give preference to the US booking. What if we're happy to get any booking at all?</p></li>
</ul>
<h2 id="second-attempt">Second attempt</h2>
<p>Suppose the sub-computations &quot;us booking&quot; and &quot;swiss booking&quot; are represented by</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> usa() (<span class="dt">int</span>, <span class="dt">bool</span>)
<span class="kw">func</span> swiss() (<span class="dt">int</span>, <span class="dt">bool</span>)</code></pre></div>
<p>Let's use some Go concepts we have just learnt to improve our holiday planning example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> <span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>)   <span class="co">// pairs used for convenience</span>
ch = <span class="fu">make</span>(<span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>))

<span class="co">// carry out both booking requsts asynchronously</span>
<span class="kw">go</span> <span class="kw">func</span>() {
    ch &lt;- usa()
}

<span class="kw">go</span> <span class="kw">func</span>() {
    ch &lt;- swiss()
}


<span class="co">// query the result</span>
x, r := &lt;- ch
<span class="kw">if</span> !r {
  x, r := &lt;- ch
  <span class="kw">if</span> r {
    <span class="co">// success</span>
  }

} <span class="kw">else</span> {
 <span class="co">// success</span>
}</code></pre></div>
<p>What if we favor the USA over Switzerland?</p>
<p>We need to introduce another channel where we give preference to the &quot;US&quot; channel.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> chan1 (<span class="dt">int</span>, <span class="dt">bool</span>)   <span class="co">// pairs used for convenience</span>
ch1 = <span class="fu">make</span>(<span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>))
<span class="kw">var</span> chan2 (<span class="dt">int</span>, <span class="dt">bool</span>)   
ch2 = <span class="fu">make</span>(<span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>))

<span class="co">// carry out both booking requsts asynchronously</span>
<span class="kw">go</span> <span class="kw">func</span>() {
    ch1 &lt;- usa()
}

<span class="kw">go</span> <span class="kw">func</span>() {
    ch2 &lt;- swiss()
}


<span class="co">// query the result</span>
x, r := &lt;- ch1
<span class="kw">if</span> !r {
  x, r := &lt;- ch2
  <span class="kw">if</span> r {
    <span class="co">// success</span>
  }

} <span class="kw">else</span> {
 <span class="co">// success</span>
}</code></pre></div>
<p>In the above, we query the result &quot;synchronously&quot;. Typically, we will do something useful while waiting for the result of the booking request. Here is the &quot;asynchronous&quot; variant.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> chan1 (<span class="dt">int</span>, <span class="dt">bool</span>)   <span class="co">// pairs used for convenience</span>
ch1 = <span class="fu">make</span>(<span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>))
<span class="kw">var</span> chan2 (<span class="dt">int</span>, <span class="dt">bool</span>)   
ch2 = <span class="fu">make</span>(<span class="kw">chan</span> (<span class="dt">int</span>, <span class="dt">bool</span>))

<span class="co">// carry out both booking requsts asynchronously</span>
<span class="kw">go</span> <span class="kw">func</span>() {
    ch1 &lt;- usa()
}

<span class="kw">go</span> <span class="kw">func</span>() {
    ch2 &lt;- swiss()
}

<span class="co">// Asynchronously</span>
<span class="kw">go</span> <span class="kw">func</span>() {
   <span class="co">// query the result</span>
   x, r := &lt;- ch1
   <span class="kw">if</span> !r {
     x, r := &lt;- ch2
     <span class="kw">if</span> r {
       <span class="co">// success</span>
     }

  } <span class="kw">else</span> {
    <span class="co">// success</span>
  }
}</code></pre></div>
<p>Erh, there's a lot of boiler-plate code required (helper threads + channels).</p>
<p>The actual program logic of our holiday planning example becomes harder to &quot;interpret&quot; from the program text alone.</p>
<p>We wish to focus on the problem domain specific aspects and hide as much as possible implementation details (threads, channels, etc).</p>
<p>Let's look closer. Isn't there a recurring program pattern? Yes, this program pattern is known as a <em>future</em>.</p>
<h2 id="final-attempt-using-futures-and-some-combinators.">Final attempt using futures and some combinators.</h2>
<p>Note: Some 'white lies'. The actual implementation is slightly more verbose.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    f1 := future(rateEuroToDollar(<span class="dv">100</span>))
    f2 := f1.then(bookUS)

    f3 := future(rateEuroToFranc(<span class="dv">100</span>))
    f4 := f3.then(bookSwiss)

    f5 := f2.orElse(f4)

    f5.onSuccess(<span class="kw">func</span>(x <span class="dt">int</span>) { fmt.Print(<span class="st">&quot;Holiday&quot;</span>) })</code></pre></div>
<ul>
<li><p>As much as possible, all computations are carried out asynchronously (non-blocking).</p></li>
<li><p>Observe that all of the above Future API functions/methods (<code>future</code>, <code>then</code>, etc) are non-blocking.</p></li>
<li><p>It becomes much easier to adapt/maintain our program.</p></li>
<li><p>For example, suppose we demand that (1) the dollar amount must be at least 40, and (2) any of the two alternatives will do (we no longer favor the US over Switzerland).</p></li>
<li><p>We can carry out the above by simply changing <em>two</em> lines in our program.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    f0 := future(rateEuroToDollar(<span class="dv">100</span>))
        f1 := f0.when(<span class="kw">func</span>(x <span class="dt">int</span>) <span class="dt">bool</span> { <span class="kw">return</span> x &gt;= <span class="dv">40</span> }) <span class="co">// (1)</span>
    f2 := f1.then(bookUS)

    f3 := future(rateEuroToFranc(<span class="dv">100</span>))
    f4 := f3.then(bookSwiss)

    f5 := f2.any(f4)  <span class="co">// (2)</span>

    f5.onSuccess(<span class="kw">func</span>(x <span class="dt">int</span>) { fmt.Print(<span class="st">&quot;Holiday&quot;</span>) })</code></pre></div>
<p>Here's the actual implementation where we make use of a generic interface. Recall that <code>interface{}</code> represents the any type (see Object in java).</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    f1 := future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) { <span class="kw">return</span> rateEuroToDollar(<span class="dv">100</span>) })
    f2 := f1.then(<span class="kw">func</span>(x <span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        i := x.(<span class="dt">int</span>)
        <span class="kw">return</span> bookUS(i)
    })

    f3 := future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) { <span class="kw">return</span> rateEuroToFranc(<span class="dv">100</span>) })
    f4 := f3.then(<span class="kw">func</span>(x <span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        i := x.(<span class="dt">int</span>)
        <span class="kw">return</span> bookSwiss(i)
    })

    f5 := f2.orElse(f4)

    f5.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) { fmt.Print(<span class="st">&quot;Holiday&quot;</span>) })</code></pre></div>
<p>Recall that the function call <code>rateEuroToDollar(100)</code> immediately computes the result. However, the <code>future</code> combinator assumes that we supply as an argument a parameter-less function which when called yields the result.</p>
</div>
<div id="futures---success-and-failure" class="slide section level1">
<h1>Futures - success and failure</h1>
<p>Future API with &quot;generic&quot; interface.</p>
<h2 id="interface">Interface</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> future(f <span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>)) Future
<span class="kw">func</span> (ft Future) get() (<span class="kw">interface</span>{}, <span class="dt">bool</span>)
<span class="kw">func</span> (ft Future) onSuccess(cb <span class="kw">func</span>(<span class="kw">interface</span>{}))
<span class="kw">func</span> (ft Future) onFailure(cb <span class="kw">func</span>())</code></pre></div>
<ul>
<li>The additional boolean value shall represent success and failure</li>
<li>Method syntax:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ft.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) { ...})</code></pre></div>
<p>Callback function applied if the future <code>ft</code> is successfull (yields some result and the boolean value true).</p>
<h2 id="sample-implementation-1">Sample implementation</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// Sadly, pairs are not first-class, so we require this wrapper struct</span>
<span class="kw">type</span> Comp <span class="kw">struct</span> {
    value <span class="kw">interface</span>{}
    ok    <span class="dt">bool</span>
}

<span class="co">// A future, once available, will be transmitted via a channel.</span>
<span class="kw">type</span> Future <span class="kw">chan</span> Comp

<span class="kw">func</span> future(f <span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>)) Future {

    future := <span class="fu">make</span>(<span class="kw">chan</span> Comp)

    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := f()
        c := Comp{value: v, ok: o}
        <span class="kw">for</span> {
            future &lt;- c
        }
    }()

    <span class="kw">return</span> future

}</code></pre></div>
<ul>
<li>Computation runs in a separate thread</li>
<li>Result communicated via channel</li>
<li>Sadly, pairs are not first-class, so we require a 'wrapper' structure</li>
<li>Recall that a <em>future</em> can be read many times. Hence, we repeatidly write the computed value into the channel by using a <code>for</code> loop which never terminates.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) get() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
    c := &lt;-ft
    <span class="kw">return</span> c.value, c.ok

}</code></pre></div>
<ul>
<li>Retrieve value by reading from channel</li>
<li>Aside:
<ul>
<li>Several reads/gets shouldn't interfere with each other</li>
<li>That is, it should be possible to concurrently execute several gets</li>
<li>Possible in our implementation?</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) onSuccess(cb <span class="kw">func</span>(<span class="kw">interface</span>{})) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := ft.get()
        <span class="kw">if</span> o {
            cb(v)
        }
    }()

}

<span class="kw">func</span> (ft Future) onFailure(cb <span class="kw">func</span>()) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        _, o := ft.get()
        <span class="kw">if</span> !o {
            cb()
        }
    }()

}</code></pre></div>
<ul>
<li>Non-blocking get variants for either success or failure</li>
</ul>
</div>
<div id="futures---orelse" class="slide section level1">
<h1>Futures - orElse</h1>
<p>Suppose, we plan a holiday. We query the exchange rate (e.g. 100 Euro to Dollar) by consulting bank1.</p>
<p>Querying the exchange rate can be done asynchronously via a future.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate1 := future( ...)</code></pre></div>
<p>What if bank1 doesn't get back to us? Well, then we consult bank2.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate2 := future( ...)</code></pre></div>
<p>How can we compose both futures in a neat way such that we only rely on <code>rate2</code> if <code>rate1</code> fails?</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate := rate1.orElse(rate2)</code></pre></div>
<p><code>orElse</code> is a new combinator (method) which combines two futures to obtain a new future. We obtain the left future if successful. Otherwise, we obtain the right future.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) orElse(ft2 Future) Future {

    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o {
            <span class="kw">return</span> v, o
        }
        v2, o2 := ft2.get()
        <span class="kw">if</span> o2 {
            <span class="kw">return</span> v2, o2
        }
        <span class="co">// if both fail, yield first one</span>
        <span class="kw">return</span> v, o
    })

}</code></pre></div>
</div>
<div id="futures---when" class="slide section level1">
<h1>Futures - when</h1>
<p>The future result shall only be used if it satisfies a guard condition.</p>
<p>Let's consider our running example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate := (rate1.when(<span class="kw">func</span>(x <span class="kw">interface</span>{}) <span class="dt">bool</span> { <span class="kw">return</span> x.(<span class="dt">int</span>) &gt;= <span class="dv">40</span>})).orElse(rate2)</code></pre></div>
<ul>
<li><p>We require that the rate given by bank1 satisfies a guard condition.</p></li>
<li><p>Here, must obtain at least 40 Dollars for our 100 Euros.</p></li>
<li><p>If the guard condition is not satisfied, the future fails.</p></li>
</ul>
<p>Short-version</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate := rate1.when(<span class="kw">func</span>(x <span class="kw">interface</span>{}) <span class="dt">bool</span> { <span class="kw">return</span> x.(<span class="dt">int</span>) &gt; <span class="dv">40</span>}).orElse(rate2)</code></pre></div>
<p><code>when</code> is a new combinator which imposes a condition on the future result. If the condition is not satisfied, we fail. Otherwise, we pass on the future result.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) when(guard <span class="kw">func</span>(<span class="kw">interface</span>{}) <span class="dt">bool</span>) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o &amp;&amp; guard(v) {
            <span class="kw">return</span> v, o
        }
        <span class="kw">return</span> v, <span class="ot">false</span>
    })

}</code></pre></div>
</div>
<div id="futures---then" class="slide section level1">
<h1>Futures - then</h1>
<p>If we get a proper exchange, <em>then</em> we can go ahead with our booking.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate := rate1.when(<span class="kw">func</span>(x <span class="kw">interface</span>{}) <span class="dt">bool</span> { <span class="kw">return</span> x.(<span class="dt">int</span>) &gt; <span class="dv">40</span>}).orElse(rate2)

booking := rate.then(<span class="kw">func</span>(dollars <span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
             <span class="co">// book a single room in hotel in local currency</span>
             <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
})</code></pre></div>
<p><code>then</code> is a combinator (method) which takes a future and a transformer function. If the future result becomes available, we create a new future computation. Otherwise, we fail.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) then(f <span class="kw">func</span>(<span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>)) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o {
            v2, o2 := f(v)
            <span class="kw">return</span> v2, o2
        }
        <span class="kw">return</span> v, <span class="ot">false</span>

    })

}</code></pre></div>
</div>
<div id="futures---any" class="slide section level1">
<h1>Futures - any</h1>
<ul>
<li>Sometimes we are happy to get <em>any</em> exchange rate.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">rate1 := ...
rate2 := ...
rate := rate1.any(rate2)</code></pre></div>
<ul>
<li>The difference to <code>orElse</code> is that we don't impose any specific order.
<ul>
<li><code>rate1</code> and <code>rate</code> will be executed asynchronously.</li>
<li>Whichever computation succeeds first will be chosen.</li>
<li>In contrast, <code>rate1.orElse(rate2)</code> strictly favors <code>rate1</code>.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) any(ft2 Future) Future {

    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {

        <span class="kw">var</span> v <span class="kw">interface</span>{}
        <span class="kw">var</span> o <span class="dt">bool</span>

        <span class="co">// check for any result to become available</span>
        <span class="kw">select</span> {
        <span class="kw">case</span> x := &lt;-ft:
            <span class="kw">if</span> x.ok {
                v = x.value
                o = x.ok
            } <span class="kw">else</span> {
                v, o = ft2.get()
            }

        <span class="kw">case</span> x2 := &lt;-ft2:
            <span class="kw">if</span> x2.ok {
                v = x2.value
                o = x2.ok
            } <span class="kw">else</span> {
                v, o = ft.get()
            }
        }

        <span class="kw">return</span> v, o
    })
}</code></pre></div>
</div>
<div id="futures---summary-of-combinators" class="slide section level1">
<h1>Futures - Summary of combinators</h1>
<ul>
<li><code>future</code>
<ul>
<li>asynchronous execution of some computation</li>
</ul></li>
<li><code>onSuccess</code>  <code>onFailure</code>
<ul>
<li>eventually query the result</li>
</ul></li>
<li><code>orElse</code>
<ul>
<li>choose among two future computations, preference given to the first one</li>
</ul></li>
<li><code>when</code>
<ul>
<li>some guard/side conditions must be fulfilled to be successful</li>
</ul></li>
<li><code>then</code>
<ul>
<li>essentially wait for a future computation to become successful and then proceed with a new computation</li>
</ul></li>
<li><code>any</code>
<ul>
<li>choose among two future computations (arbitrary choice)</li>
</ul></li>
</ul>
</div>
<div id="exercise-futures" class="slide section level1">
<h1>Exercise Futures</h1>
<p>Create a small application where you asynchronously execute 3 http requests to different pages and pick the first one which sends a response. Print the header to console.</p>
<p>Hints:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">
<span class="kw">func</span> req() {
...
response, err := http.Get(<span class="st">&quot;www.someUrl.com&quot;</span>)    --- Http request
response.Header                                 --- Get the header
..
}</code></pre></div>
<h2 id="example-solution">Example solution</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">
<span class="kw">func</span> getSite(url <span class="dt">string</span>, timeout time.Duration) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        resp, err := http.Get(url)
        time.Sleep(timeout)
        <span class="kw">if</span> err == <span class="ot">nil</span> {
            <span class="kw">return</span> resp, <span class="ot">true</span>
        }
        <span class="kw">return</span> err, <span class="ot">false</span>
    })
}

<span class="kw">func</span> main() {
    spiegel := getSite(<span class="st">&quot;http://www.spiegel.de&quot;</span>, <span class="dv">0</span> * time.Second)
    stern := getSite(<span class="st">&quot;http://www.stern.de&quot;</span>, <span class="dv">0</span> * time.Second)
    welt := getSite(<span class="st">&quot;http://www.welt.com&quot;</span>, <span class="dv">0</span> * time.Second)
    first := spiegel.any(stern).any(welt)

    result, succeed := first.get()
    <span class="kw">if</span> succeed {
        response := result.(*http.Response)
        fmt.Println(response.Request.URL)
        header := response.Header
        fmt.Println(header)
        date := header.Get(<span class="st">&quot;Date&quot;</span>)
        fmt.Println(date)
    }
}</code></pre></div>
</div>
<div id="promises" class="slide section level1">
<h1>Promises</h1>
<p>The story so far:</p>
<ul>
<li>Futures represent asynchronous computations</li>
<li>Futures are read-only and their result can be queried many times (once the result becomes available)</li>
</ul>
<p>Is this enough for typical (concurrent) programming tasks?</p>
<p>Think about the classic producer-consumer pattern?</p>
<p>Currently, we lack an abstraction to <em>complete</em> a future at a specific program point.</p>
<p>Promises:</p>
<ul>
<li>a write-once data container</li>
<li>initially empty</li>
<li>yields a future</li>
<li>can be completed (data value set) at a specific program point.</li>
</ul>
<h2 id="producer-consumer-example">Producer-Consumer Example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> producer(p Promise) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        <span class="co">// (1) do something</span>
        <span class="co">// (2) fulfill promise</span>
        p.success(<span class="dv">3</span>)
        <span class="co">// do something else</span>
        <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
    })

}

<span class="kw">func</span> consumer(p Promise) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        <span class="co">// (1) do something</span>
        p.future().onSuccess(
            <span class="kw">func</span>(x <span class="kw">interface</span>{}) {
                <span class="co">// do something with result x</span>
            })

        <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
    })

}</code></pre></div>
</div>
<div id="promises---basics" class="slide section level1">
<h1>Promises - Basics</h1>
<ul>
<li>A promise yields a future</li>
<li>A promise shall be fulfilled (written) only once where <code>full</code> indicates the status (fulfilled yet or not)</li>
<li>Must protect access to <code>full</code> via a lock</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Promise <span class="kw">struct</span> {
    lock <span class="kw">chan</span> <span class="dt">int</span>
    ft   Future
    full <span class="dt">bool</span>
}</code></pre></div>
<ul>
<li>Create a promise</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> promise() Promise {
    <span class="kw">return</span> Promise{full: <span class="ot">false</span>, ft: <span class="fu">make</span>(<span class="kw">chan</span> Comp), lock: <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">1</span>)}
}</code></pre></div>
<ul>
<li>Obtaining the future from a promise is easy</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (pr Promise) future() Future {
    <span class="kw">return</span> pr.ft
}</code></pre></div>
<ul>
<li>Let's first consider a &quot;try&quot; Variant</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (pr *Promise) trySuccess(val <span class="kw">interface</span>{}) {
    pr.lock &lt;- <span class="dv">1</span>
    <span class="kw">if</span> !pr.full {
        pr.full = <span class="ot">true</span>
        <span class="kw">go</span> <span class="kw">func</span>() {
            <span class="kw">for</span> {
                pr.ft &lt;- Comp{value: val, ok: <span class="ot">true</span>}
            }
        }()
    }

    &lt;-pr.lock
}
<span class="co">// pr *Promise means that pr is passed by &#39;reference&#39;</span>
<span class="co">// necessary cause we might change the full status</span></code></pre></div>
<ul>
<li><p>Try to fulfill if not already fulfilled (no operation in this case then)</p></li>
<li><p>Useful in case we wait for competing results (answers from different sources but only care about at most one answer)</p></li>
<li><p>We can also fail a promise</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (pr *Promise) tryFail() {
    pr.lock &lt;- <span class="dv">1</span>
    <span class="kw">if</span> !pr.full {
        pr.full = <span class="ot">true</span>
        <span class="kw">go</span> <span class="kw">func</span>() {
            <span class="kw">for</span> {
            pr.ft &lt;- Comp{ok: <span class="ot">false</span>}
                    }
        }()
    }

    &lt;-pr.lock

}</code></pre></div>
<ul>
<li>What about success?
<ul>
<li>Similar to <code>trySuccess</code> but in case there are multiple <code>success</code> calls we should raise an error (e.g. by throwing an exception).</li>
</ul></li>
<li>Another handy combinator.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (p *Promise) tryCompleteWith(f Future) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := f.get()
        <span class="kw">if</span> o {
            p.trySuccess(v)
        } <span class="kw">else</span> {
            p.tryFail()
        }
    }()
}</code></pre></div>
</div>
<div id="promises---first" class="slide section level1">
<h1>Promises - first</h1>
<ul>
<li><p>Recall the implementation of <code>any</code> for futures.</p></li>
<li><p>With promises this can be implemented as follows.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> first(f1 Future, f2 Future) Future {
    p := promise()

    p.tryCompleteWith(f1)
    p.tryCompleteWith(f2)

    <span class="kw">return</span> p.future()

}</code></pre></div>
<h2 id="first-versus-any"><code>first</code> versus <code>any</code></h2>
<p>There is a subtle semantic difference.</p>
<p>Consider the case where</p>
<ul>
<li><p><code>f1</code> yields a failing value (i.e. boolean flag yields false)</p></li>
<li><p><code>f2</code> is not available yet</p></li>
</ul>
<p>Then, we can observe the following:</p>
<ul>
<li><p>`first(f1,f2) yields a with future with failing value</p>
<ul>
<li><p>In <code>first</code> the call <code>p.tryCompleteWith(f1)</code> encounters an empty promise.</p></li>
<li><p>This then leads to the subsequent call <code>p.tryFail()</code></p></li>
</ul></li>
<li><p><code>f1.any(f2) yields</code>f2`</p>
<ul>
<li><p>In <code>any</code> the first select case is available (<code>f1</code> is available)</p></li>
<li><p>Because <code>f1</code> yields a failing value, <code>f2</code> is returned.</p></li>
</ul></li>
</ul>
</div>
<div id="exercise-promises" class="slide section level1">
<h1>Exercise Promises</h1>
<p>Try to solve the same problem as before with the Promises Api.</p>
<h2 id="example-solution-1">Example solution</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">
<span class="kw">func</span> getSite(url <span class="dt">string</span>, timeout time.Duration) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        resp, err := http.Get(url)
        time.Sleep(timeout)
        <span class="kw">if</span> err == <span class="ot">nil</span> {
            <span class="kw">return</span> resp, <span class="ot">true</span>
        }
        <span class="kw">return</span> err, <span class="ot">false</span>
    })
}

<span class="kw">func</span> main() {
    spiegel := querySite(<span class="st">&quot;http://www.spiegel.de&quot;</span>, <span class="dv">0</span> * time.Second)
    stern := querySite(<span class="st">&quot;http://www.stern.de&quot;</span>, <span class="dv">0</span> * time.Second)
    welt := querySite(<span class="st">&quot;http://www.welt.com&quot;</span>, <span class="dv">0</span> * time.Second)

    first := first(spiegel, stern, welt)

    result, succeed := first.get()
    <span class="kw">if</span> succeed {
        response := result.(*http.Response)
        fmt.Println(response.Request.URL)
        header := response.Header
        fmt.Println(header)
        date := header.Get(<span class="st">&quot;Date&quot;</span>)
        fmt.Println(date)
    }
}</code></pre></div>
</div>
<div id="conclusion" class="slide section level1">
<h1>Conclusion</h1>
<ul>
<li><p>Futures are read-only and their result can be queried many times (once the result becomes available)</p></li>
<li><p>Promises are a write-once data container.</p></li>
<li><p>We can query the future result of a promise</p></li>
<li><p>We can fulfill/fail a promise at a specific program point</p></li>
<li><p>Powerful combinators (any, ...)</p></li>
</ul>
<p>What we have done.</p>
<ul>
<li>Future and promises library in GoLang</li>
</ul>
</div>
<div id="exercises" class="slide section level1">
<h1>Exercises</h1>
<h2 id="coordination">Coordination</h2>
<ul>
<li><p>Below is a list of (concurrent) programming exercises which involve some classic coordination/synchronization tasks.</p></li>
<li><p>Implement as many as possible in Go.</p></li>
<li><p>If possible make use of futures and promises.</p></li>
<li><p>Futures and promises might not always the best fit. Part of the exercise is to find out how useful and versatile futures and promises are in practice.</p></li>
</ul>
<h3 id="dining-philosoper">Dining philosoper</h3>
<p>It's a classic. Everybody knows this one, so details are omitted.</p>
<!--
Solving The Dining Philosophers Problem With Asynchronous Agents
http://msdn.microsoft.com/en-us/magazine/dd882512.aspx
-->
<h3 id="sleeping-barber">Sleeping barber</h3>
<p>Consider a barber shop where there is only one barber. When there are no customers the barber sleeps. When a customer arrives he awakes and cuts the customer's hair. In case of several customers arriving the barber chooses one randomly.</p>
<p>Variations:</p>
<ul>
<li><p>There are n waiting chairs. If the barber is busy, the customer takes a seat. If there are no seats left, the customer leaves (and tries again after a certain amount of time)</p></li>
<li><p>There are several barbers serving customers</p></li>
</ul>
<h3 id="santa-claus">Santa claus</h3>
<p>Santa repeatedly sleeps until wakened by either all of his nine reindeer, back from their holidays, or by a group of three of his ten elves. If awakened by the reindeer, he harnesses each of them to his sleigh, delivers toys with them and finally unharnesses them (allowing them to go off on holiday). If awakened by a group of elves, he shows each of the group into his study, consults with them on toy R&amp;D and finally shows them each out (allowing them to go back to work).</p>
<p>Variations:</p>
<ul>
<li>Santa gives priority to the reindeer in the case that there is both a group of elves and a group of reindeer waiting</li>
</ul>
<h3 id="gossiping-girls">Gossiping girls</h3>
<p>There n girls, each of whom knows a unique piece of initial information. They communicate by telephone calls, and whenever two speak they share all the gossip that they know. The goal is to determine the minimum number of calls necessary for all of the girls to learn all of the initial information.</p>
<h2 id="from-futurespromises-to-golang">From futures/promises to GoLang</h2>
<p>We have seen that futures/promises can be expressed in terms of goroutines, synchronous channels and select.</p>
<p>An interesting question is, can goroutines, synchronous channels and select be expressed in terms of futures/promises?</p>
</div>
<div id="appendix---summary-of-futures-and-promises" class="slide section level1">
<h1>Appendix - Summary of futures and promises</h1>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="co">// Sadly, pairs are not first-class, so we require this wrapper struct</span>
<span class="kw">type</span> Comp <span class="kw">struct</span> {
    value <span class="kw">interface</span>{}
    ok    <span class="dt">bool</span>
}

<span class="co">// A future, once available, will be transmitted via a channel.</span>
<span class="kw">type</span> Future <span class="kw">chan</span> Comp

<span class="kw">func</span> future(f <span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>)) Future {

    future := <span class="fu">make</span>(<span class="kw">chan</span> Comp)

    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := f()
        c := Comp{value: v, ok: o}
        <span class="kw">for</span> {
            future &lt;- c
        }
    }()

    <span class="kw">return</span> future

}

<span class="kw">func</span> (ft Future) get() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
    c := &lt;-ft
    <span class="kw">return</span> c.value, c.ok

}

<span class="kw">func</span> (ft Future) onSuccess(cb <span class="kw">func</span>(<span class="kw">interface</span>{})) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := ft.get()
        <span class="kw">if</span> o {
            cb(v)
        }
    }()

}

<span class="kw">func</span> (ft Future) onFailure(cb <span class="kw">func</span>()) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        _, o := ft.get()
        <span class="kw">if</span> !o {
            cb()
        }
    }()

}

<span class="kw">func</span> (ft Future) then(f <span class="kw">func</span>(<span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>)) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o {
            v2, o2 := f(v)
            <span class="kw">return</span> v2, o2
        }
        <span class="kw">return</span> v, <span class="ot">false</span>

    })

}

<span class="kw">func</span> (ft Future) orElse(ft2 Future) Future {

    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o {
            <span class="kw">return</span> v, o
        }
        v2, o2 := ft2.get()
        <span class="kw">if</span> o2 {
            <span class="kw">return</span> v2, o2
        }
        <span class="co">// if both fail, yield first one</span>
        <span class="kw">return</span> v, o
    })

}

<span class="kw">func</span> (ft Future) any(ft2 Future) Future {

    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {

        <span class="kw">var</span> v <span class="kw">interface</span>{}
        <span class="kw">var</span> o <span class="dt">bool</span>

        <span class="co">// check for any result to become available</span>
        <span class="kw">select</span> {
        <span class="kw">case</span> x := &lt;-ft:
            <span class="kw">if</span> x.ok {
                v = x.value
                o = x.ok
            } <span class="kw">else</span> {
                v, o = ft2.get()
            }

        <span class="kw">case</span> x2 := &lt;-ft2:
            <span class="kw">if</span> x2.ok {
                v = x2.value
                o = x2.ok
            } <span class="kw">else</span> {
                v, o = ft2.get()
            }
        }

        <span class="kw">return</span> v, o
    })
}

<span class="kw">func</span> (ft Future) when(guard <span class="kw">func</span>(<span class="kw">interface</span>{}) <span class="dt">bool</span>) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v, o := ft.get()
        <span class="kw">if</span> o &amp;&amp; guard(v) {
            <span class="kw">return</span> v, o
        }
        <span class="kw">return</span> v, <span class="ot">false</span>
    })

}

<span class="kw">type</span> Promise <span class="kw">struct</span> {
    lock <span class="kw">chan</span> <span class="dt">int</span>
    ft   Future
    full <span class="dt">bool</span>
}

<span class="kw">func</span> promise() Promise {
    <span class="kw">return</span> Promise{full: <span class="ot">false</span>, ft: <span class="fu">make</span>(<span class="kw">chan</span> Comp), lock: <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">1</span>)}
}

<span class="kw">func</span> (pr Promise) future() Future {
    <span class="kw">return</span> pr.ft
}

<span class="co">// success has single-assignment semantics.</span>
<span class="co">// Currently, we simply ignore multiple assignments.</span>
<span class="co">// Hence, we refer to the method as &#39;trySuccess&#39;.</span>
<span class="co">// That is, in case of several attemps, only the first will succeed.</span>
<span class="kw">func</span> (pr *Promise) trySuccess(val <span class="kw">interface</span>{}) {
    pr.lock &lt;- <span class="dv">1</span>
    <span class="kw">if</span> !pr.full {
        pr.full = <span class="ot">true</span>
        <span class="kw">go</span> <span class="kw">func</span>() {
            <span class="kw">for</span> {
                pr.ft &lt;- Comp{value: val, ok: <span class="ot">true</span>}
            }
        }()
    }

    &lt;-pr.lock
}

<span class="kw">func</span> (pr *Promise) success(val <span class="kw">interface</span>{}) {
    pr.trySuccess(val)
}

<span class="co">// See trySuccess</span>
<span class="kw">func</span> (pr *Promise) tryFail() {
    pr.lock &lt;- <span class="dv">1</span>
    <span class="kw">if</span> !pr.full {
        pr.full = <span class="ot">true</span>
        <span class="kw">go</span> <span class="kw">func</span>() {
            <span class="kw">for</span> {
                pr.ft &lt;- Comp{ok: <span class="ot">false</span>}
            }
        }()
    }

    &lt;-pr.lock

}

<span class="kw">func</span> (p *Promise) tryCompleteWith(f Future) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := f.get()
        <span class="kw">if</span> o {
            p.trySuccess(v)
        } <span class="kw">else</span> {
            p.tryFail()
        }
    }()
}

<span class="kw">func</span> first(f1 Future, f2 Future) Future {
    p := promise()

    p.tryCompleteWith(f1)
    p.tryCompleteWith(f2)

    <span class="kw">return</span> p.future()

}

<span class="kw">func</span> rateEuroToDollar(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">return</span> x * <span class="dv">2</span>, <span class="ot">true</span>
}

<span class="kw">func</span> rateEuroToFranc(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">return</span> x * <span class="dv">3</span>, <span class="ot">true</span>
}

<span class="kw">func</span> rateEuroToSwiss(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">return</span> x * <span class="dv">1</span>, <span class="ot">true</span>
}

<span class="kw">func</span> bookUS(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
}

<span class="kw">func</span> bookSwiss(x <span class="dt">int</span>) (<span class="dt">int</span>, <span class="dt">bool</span>) {
    <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
}

<span class="kw">func</span> naiveHolidayPlanning() {
    d, d_ok := rateEuroToDollar(<span class="dv">100</span>)
    r, r_ok := bookUS(d)

    <span class="kw">if</span> d_ok &amp;&amp; r_ok {
        fmt.Printf(<span class="st">&quot;Going to the US %d&quot;</span>, r)
    } <span class="kw">else</span> {
        f, f_ok := rateEuroToSwiss(<span class="dv">100</span>)
        r, r_ok := bookSwiss(f)

        <span class="kw">if</span> f_ok &amp;&amp; r_ok {
            fmt.Printf(<span class="st">&quot;Going to Switzerland %d&quot;</span>, r)
        }

    }

}

<span class="kw">func</span> futureHolidayPlanning() {
    f1 := future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) { <span class="kw">return</span> rateEuroToDollar(<span class="dv">100</span>) })
    <span class="co">//  f2 := f1.then(bookUS)</span>
    f2 := f1.then(<span class="kw">func</span>(x <span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        i := x.(<span class="dt">int</span>)
        <span class="kw">return</span> bookUS(i)
    })

    f3 := future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) { <span class="kw">return</span> rateEuroToFranc(<span class="dv">100</span>) })
    f4 := f3.then(<span class="kw">func</span>(x <span class="kw">interface</span>{}) (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        i := x.(<span class="dt">int</span>)
        <span class="kw">return</span> bookSwiss(i)
    })

    f5 := f2.orElse(f4)

    f5.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) { fmt.Print(<span class="st">&quot;Holiday&quot;</span>) })

}

<span class="kw">func</span> main() {


    futureHolidayPlanning()
    <span class="co">// wait a bit, so we get to see some results</span>
    time.Sleep(<span class="dv">2</span> * <span class="fl">1e9</span>)

}</code></pre></div>
</div>
<div id="sample-solutions" class="slide section level1">
<h1>Sample solutions</h1>
<p>We consider sample solutions for</p>
<ul>
<li><p>sleeping barber,</p></li>
<li><p>santa claus, and</p></li>
<li><p>dining philosphers.</p></li>
</ul>
<p>There are well-known solutions which make use of message-based primitives such as send/receive.</p>
<p>Our goal is to consider solutions which employ futures and promises. In the following, we discuss each of the above examples.</p>
<p>We briefly summarize some general insights we gained:</p>
<ul>
<li><p>The examples inspire new functionality</p>
<ul>
<li><p>Santa Claus (<code>firstSucc</code>, <code>collectN</code>)</p></li>
<li><p>Dining philosopher (atomic trySuccess of several promises)</p></li>
</ul></li>
<li><p>Sleeping barber:</p>
<ul>
<li><p>Appears to be the least elegant solution.</p></li>
<li><p>We lack a queuing mechanism and a failed customer has to retry</p></li>
</ul></li>
<li><p>Dining philosophers:</p>
<ul>
<li>Solution has issues which could be solved assuming there is support to atomically trySuccess several promises,</li>
</ul></li>
<li><p>Santa claus:</p>
<ul>
<li>Appears to be the most convincing solution</li>
</ul></li>
<li><p>Futures/promises are highly useful for expressing high-level coordination tasks</p></li>
<li><p>But they are not a silver bullet (which is no surprise)</p></li>
</ul>
</div>
<div id="sample-solution---sleeping-barber" class="slide section level1">
<h1>Sample solution - Sleeping barber</h1>
<p>Some helper function</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> sleep(x <span class="dt">int</span>, y <span class="dt">int</span>) {
    <span class="kw">var</span> z time.Duration
    z = (time.Duration)((rand.Int()%x + y) * <span class="dv">10</span>)
    time.Sleep(z * time.Millisecond)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">/////////////////////////////</span>
<span class="co">// Hair salon</span>
<span class="co">// </span>
<span class="co">// Each round</span>
<span class="co">// - customer start race for barber</span>
<span class="co">// - barber waits for customer</span>
<span class="co">// - new round starts once a customer gets a hair cut</span>
<span class="co">//</span>
<span class="co">// Effectively, an application of the &#39;producer-consumer&#39; pattern.</span>
<span class="co">// Cons:</span>
<span class="co">//   - no queuing mechanism</span>
<span class="co">//   - a failed customer simply has to retry</span>
<span class="co">// Observations:</span>
<span class="co">//   - we have to ensure that the id of the customer is in the correct scope</span>
<span class="co">//   - customers are chosen randomly as expected</span>

<span class="kw">func</span> salon() {

    <span class="kw">for</span> {
        barber := promise()
        done := promise()
        <span class="co">// barber</span>
        barber.future().onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) {
            fmt.Printf(<span class="st">&quot;Customer %d gets a hair cut </span><span class="ch">\n</span><span class="st">&quot;</span>, x.(<span class="dt">int</span>))
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
            done.trySuccess(<span class="dv">1</span>)
        })

        <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++ {
            <span class="co">// customer i. we create a future here, to add a bit of &#39;randomess&#39; to trySuccess.</span>
            <span class="co">// Because we don&#39;t know when the execution of the future starts we have to use an additional variable (id)</span>
            <span class="co">// to store the information about the current user. If we use i as closure the result will always be 5.</span>
            <span class="co">// The reason therefore is that i is not in the correct execution scope so we don&#39;t get a &quot;snapshot&quot; of the value.</span>
            id := i
            future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
                sleep(<span class="dv">5</span>,<span class="dv">5</span>)
                barber.trySuccess(id)
                <span class="kw">return</span> <span class="dv">1</span>, <span class="ot">true</span>
            })
        }

        done.future().get()

    }

}</code></pre></div>
</div>
<div id="sample-solution---santa-claus" class="slide section level1">
<h1>Sample solution - Santa claus</h1>
<p>The main concern of futures and promises is to deal/coordinate asynchronous computations whose result will only be available somewhen in the future. In our case, we waint for a deer or elf to become &quot;ready&quot;. We will use a fairly simplistic model to check for the &quot;ready&quot; result.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> sleep(x <span class="dt">int</span>, y <span class="dt">int</span>) {
    <span class="kw">var</span> z time.Duration
    z = (time.Duration)((rand.Int()%x + y) * <span class="dv">10</span>)
    time.Sleep(z * time.Millisecond)


<span class="kw">func</span> elfReady() <span class="dt">int</span> {
    sleep(<span class="dv">3</span>, <span class="dv">3</span>)
    fmt.Print(<span class="st">&quot;elf ready </span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">return</span> <span class="dv">1</span>
}

<span class="kw">func</span> deerReady() <span class="dt">int</span> {
    sleep(<span class="dv">3</span>, <span class="dv">2</span>)
    fmt.Print(<span class="st">&quot;deer ready </span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">return</span> <span class="dv">1</span>
}</code></pre></div>
<p>We simply start a timer and then report after some time that a deer and elf is ready. We don't care which deer/elf is ready. The above functions simply yield a integer number after a fixed time period.</p>
<p>Given that deers/elves are not instantly ready, we use a future to perform the &quot;ready&quot; computations.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> elf() Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        <span class="kw">return</span> elfReady(), <span class="ot">true</span>
    })

}

<span class="kw">func</span> deer() Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        <span class="kw">return</span> deerReady(), <span class="ot">true</span>
    })

}</code></pre></div>
<p>Now, it starts getting more interesting. We require either a group of three elves or nine deers. So, we start three <code>elf</code> future computations and nine <code>deer</code> future computations. How can we check that within each group all computations have succeeded? We require yet another combinator to achieve this.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (ft Future) collect(ft2 Future) Future {
    <span class="kw">return</span> future(<span class="kw">func</span>() (<span class="dt">int</span>, <span class="dt">bool</span>) {
        v, o := ft.get()
        v2, o2 := ft2.get()
        <span class="kw">if</span> o &amp;&amp; o2 {
            <span class="kw">return</span> v + v2, <span class="ot">true</span>
        }
        dummy := <span class="dv">1</span>
        <span class="kw">return</span> dummy, <span class="ot">false</span> 
    })

}</code></pre></div>
<p>The above <code>collect</code> combinator waits for the result of two futures. In our simplistic model, we combine results by simply adding up the resulting integer values. [Aside: In a more realistic implementation, we should indicate which future has failed and for example give preference to the first failed future]</p>
<p>So, santa simply needs to <code>collect</code> three <code>elf</code> futures and nine <code>deer</code> futures.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    elves := collectN(<span class="dv">3</span>, elf)
    deers := collectN(<span class="dv">9</span>, deer)</code></pre></div>
<p>where</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> collectN(x <span class="dt">int</span>, f <span class="kw">func</span>() Future) Future {
    <span class="kw">var</span> y Future
    <span class="kw">if</span> x == <span class="dv">1</span> {
        y = f()
    } <span class="kw">else</span> { <span class="co">// no check if below 1</span>
        y = f().collect(collectN(x<span class="dv">-1</span>, f))
    }
    <span class="kw">return</span> y

}</code></pre></div>
<p>What remains is to check for the first successful group via the following combinator</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> firstSucc(f1 Future, f2 Future) Future {
    p := promise()

    p.trySuccCompleteWith(f1)
    p.trySuccCompleteWith(f2)

    <span class="kw">return</span> p.future()

}</code></pre></div>
<p>where</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> (p *Promise) trySuccCompleteWith(f Future) {
    <span class="kw">go</span> <span class="kw">func</span>() {
        v, o := f.get()
        <span class="kw">if</span> o {
            p.trySuccess(v)
        }
    }()
}</code></pre></div>
<p>Note that the difference to <code>tryCompleteWith</code> is that we only <em>try</em> in case the future is successful.</p>
<p>Finally, here comes our santa claus.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> santaLoop() {

    <span class="kw">for</span> {

        elves := collectN(<span class="dv">3</span>, elf)
        deers := collectN(<span class="dv">9</span>, deer)
        group := firstSucc(elves, deers).when(santaSleeping)

        x, _ := group.get()
        santaSleeps = <span class="ot">false</span>
        <span class="kw">if</span> x == <span class="dv">3</span> {
            fmt.Print(<span class="st">&quot;R&amp;D </span><span class="ch">\n</span><span class="st">&quot;</span>)
        }
        <span class="kw">if</span> x == <span class="dv">9</span> {
            fmt.Print(<span class="st">&quot;Deliver toys </span><span class="ch">\n</span><span class="st">&quot;</span>)
        }
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        santaSleeps = <span class="ot">true</span>

    }
}</code></pre></div>
<p>In the above, we use a simply test to check if santa is back and sleeping</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> santaSleeping(x <span class="dt">int</span>) <span class="dt">bool</span> {
    <span class="kw">return</span> santaSleeps

}</code></pre></div>
<p>where</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> santaSleeps <span class="dt">bool</span></code></pre></div>
<p>is some global variable.</p>
<h2 id="discussion">Discussion</h2>
<h3 id="new-featurescombinators">New features/combinators</h3>
<p>The Santa Claus example lead us to enricht the set of combinators</p>
<ul>
<li><p><code>collectN</code> which resembles a form of a barrier</p></li>
<li><p><code>firstSucc</code> which is a variant of <code>any</code> but only cares about the first successful future</p></li>
</ul>
<h3 id="priority">Priority</h3>
<p>We have not enforced the priority rule:</p>
<p>Santa gives priority to the reindeer in the case that there is both a group of elves and a group of reindeer waiting.</p>
<p>This seems rather tricky to achieve with futures and promises. The problem lies in the definiton of <code>firstSucc</code>. In case both futures are successful, one of the two will be randomly choosen.</p>
<p>Recall</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> firstSucc(f1 Future, f2 Future) Future {
    p := promise()

    p.trySuccCompleteWith(f1)
    p.trySuccCompleteWith(f2)

    <span class="kw">return</span> p.future()

}</code></pre></div>
<p>Given that our futures are implemented via channels, we might give an alternative implementation which employs a form of 'nested' select statements to give priority to the first future.</p>
<h2 id="avoid-complete-group-retry">Avoid complete group retry</h2>
<p>Consider the following scenario. Two elves are ready but there's no third elf in sight. Nine deers are ready and santa is sleeping. Hence, we select the group of nine deers and santa delivers toys. Meanwhile, a third elf arrives.</p>
<p>In our current implementation, in each round we perform a <em>complete retry</em> for each group even if that group has not been selected. Recall</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> santaLoop() {

    <span class="kw">for</span> {

        elves := collectN(<span class="dv">3</span>, elf)
        deers := collectN(<span class="dv">9</span>, deer)
        group := firstSucc(elves, deers).when(santaSleeping)
               ...
       }
}</code></pre></div>
<p>It seems wasteful to start three <code>elf</code> futures where we haven't used them yet. It would be much smarter to reuse parts of the computations of the previous round.</p>
<p>Idea: Restart collection of three <code>elf</code> or nine <code>deer</code> futures only if necessary. We will make use of promises to achieve this.</p>
</div>
<div id="second-santa-solution-making-use-of-promises" class="slide section level1">
<h1>Second santa solution making use of promises</h1>
<p>We signal successful assembly of a group via a promise</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> colElves(p Promise) {
    p.tryCompleteWith(collectN(<span class="dv">3</span>, elf))
}

<span class="kw">func</span> colDeers(p Promise) {
    p.tryCompleteWith(collectN(<span class="dv">9</span>, deer))
}</code></pre></div>
<p>Santa creates a promise for each group. We reuse the old promise if the promise hasn't been used yet.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> santa2() {

    <span class="kw">var</span> pE Promise
    <span class="kw">var</span> pD Promise

    pE = promise()
    pD = promise()
    colElves(pE)
    colDeers(pD)

    <span class="kw">for</span> {

        group := firstSucc(pE.future(), pD.future()).when(santaSleeping)

        x, _ := group.get()
        santaSleeps = <span class="ot">false</span>

        <span class="kw">if</span> x == <span class="dv">3</span> {
            fmt.Print(<span class="st">&quot;R&amp;D </span><span class="ch">\n</span><span class="st">&quot;</span>)
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
            santaSleeps = <span class="ot">true</span>
            pE = promise()
            colElves(pE)

        }
        <span class="kw">if</span> x == <span class="dv">9</span> {
            fmt.Print(<span class="st">&quot;Deliver toys </span><span class="ch">\n</span><span class="st">&quot;</span>)
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
            santaSleeps = <span class="ot">true</span>
            pD = promise()
            colDeers(pD)
        }

    }

}</code></pre></div>
<p>In the above, consider the case that a group of three elves becomes available.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">        <span class="kw">if</span> x == <span class="dv">3</span> {
            fmt.Print(<span class="st">&quot;R&amp;D </span><span class="ch">\n</span><span class="st">&quot;</span>)
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
            santaSleeps = <span class="ot">true</span>
            pE = promise()
            colElves(pE)

        }</code></pre></div>
<p>We create a new promise for elves but reuse the existing promise for deers. After all, meanwhile a group of nine deers may have assembled successfully.</p>
</div>
<div id="sample-solution---dining-philosopher" class="slide section level1">
<h1>Sample solution - dining philosopher</h1>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">
<span class="co">/////////////////////////////</span>
<span class="co">// Dining philosopher</span>
<span class="co">// </span>
<span class="co">// Idea:</span>
<span class="co">// - forks represented by promises</span>
<span class="co">// - philos race for two forks (left and right)</span>
<span class="co">// There&#39;s an issue:</span>
<span class="co">// - Say we only obtain one fork but not the other!</span>
<span class="co">// - Then we fail to eat.</span>
<span class="co">// - So there could be the scenario that each philospher only gets one fork</span>
<span class="co">// - There&#39;s no deadlock as we start a new round (race)</span>
<span class="co">// </span>
<span class="co">// What we would like to express is that</span>
<span class="co">// trying to succeed two promises is performed atomically.</span>
<span class="co">// That is:</span>
<span class="co">//</span>
<span class="co">// atomically {</span>
<span class="co">//  left.trySuccess(id)</span>
<span class="co">//  right.trySuccess(id)</span>
<span class="co">// }</span>
<span class="co">//</span>
<span class="co">// We either can successfuly set both promises or none of the two is set.</span>

<span class="kw">func</span> philo(id <span class="dt">int</span>, left *Promise, right *Promise) Future {
    <span class="kw">var</span> f Future

    fmt.Printf(<span class="st">&quot;Philo %d start race </span><span class="ch">\n</span><span class="st">&quot;</span>, id)

    <span class="co">// race for two forks</span>
    left.trySuccess(id)
    right.trySuccess(id)

    fmt.Printf(<span class="st">&quot;race done </span><span class="ch">\n</span><span class="st">&quot;</span>)

    <span class="co">// check if successful</span>
    f = future(<span class="kw">func</span>() (<span class="kw">interface</span>{}, <span class="dt">bool</span>) {
        v1, o1 := left.future().get()
        v2, o2 := right.future().get()

        <span class="kw">if</span> o1 &amp;&amp; o2 &amp;&amp; v1.(<span class="dt">int</span>) == id &amp;&amp; v2.(<span class="dt">int</span>) == id {
            <span class="kw">return</span> id, <span class="ot">true</span>
        }
        <span class="kw">return</span> id, <span class="ot">false</span>

    })
    <span class="kw">return</span> f
}

<span class="kw">func</span> main() {

    <span class="kw">for</span> {

        fmt.Printf(<span class="st">&quot;new round </span><span class="ch">\n</span><span class="st">&quot;</span>)

        <span class="kw">var</span> f1 Promise
        <span class="kw">var</span> f2 Promise
        <span class="kw">var</span> f3 Promise

        f1 = promise()
        f2 = promise()
        f3 = promise()

        p1 := philo(<span class="dv">1</span>, &amp;f1, &amp;f2)
        p2 := philo(<span class="dv">2</span>, &amp;f2, &amp;f3)
        p3 := philo(<span class="dv">3</span>, &amp;f3, &amp;f1)

        p1.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) {
            fmt.Printf(<span class="st">&quot;Philo 1 eats </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })

        p1.onFailure(<span class="kw">func</span>() {
            fmt.Printf(<span class="st">&quot;Philo 1 cannot eat </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })

        p2.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) {
            fmt.Printf(<span class="st">&quot;Philo 2 eats </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })
        p2.onFailure(<span class="kw">func</span>() {
            fmt.Printf(<span class="st">&quot;Philo 2 cannot eat </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })

        p3.onSuccess(<span class="kw">func</span>(x <span class="kw">interface</span>{}) {
            fmt.Printf(<span class="st">&quot;Philo 3 eats </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })
        p3.onFailure(<span class="kw">func</span>() {
            fmt.Printf(<span class="st">&quot;Philo 3 cannot eat </span><span class="ch">\n</span><span class="st">&quot;</span>)
        })

        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)

    }

}</code></pre></div>
</div>
</body>
</html>
